#if !defined (TOKEN_ID_H)
#define TOKEN_ID_H

namespace PGParse {

/**
 * We want to combine:
 * 
 *   1. the keyword information from the Postgres kwlist file.
 *   2. the token ids generated by Lemon.
 *   3. some additional metadata that we want to associate
 *      with tokens.
 * 
 * We keep a single list of token types, and then create a lookup
 * table to get at the additional information.  
 */

// Extract token identifiers from kwlist.h
//
#define PG_KEYWORD(text, id, category)		id##_KW,

enum TokenId {
	
	// INVALID is a catch-all error condition, and also
	// used as the starting sentinal for the list.
	//
	INVALID,
	
	// Keywords all end in _KW.  Taken directly from Postgres.
	//
#include "kwlist.h"
	KW_SENTINAL,
	
	// Other token types.
	//
	BIT_STRING_T,
	HEX_STRING_T,
	UNI_STRING_T,
	STRING_T,
	INTEGER_T,
	FLOAT_T,
	DOLQ_STRING_T,
	NCHAR_FLAG_T,
	IDENTIFIER_T,
	DQ_IDENTIFIER_T,
	UNICODE_IDENTIFIER_T,
	WHITESPACE_T,
	COMMENT_T,
	TYPECAST_T,
	DOTDOT_T,
	COLONEQUALS_T,
	COMMA_T,
	OPEN_PAREN_T,
	CLOSE_PAREN_T,
	OPEN_BRACKET_T,
	CLOSE_BRACKET_T,
	DOT_T,
	SEMI_COLON_T,
	COLON_T,
	PLUS_T,
	MINUS_T,
	STAR_T,
	SLASH_T,
	PERCENT_T,
	CARAT_T,
	LESS_THAN_T,
	GREATER_THAN_T,
	EQUAL_T,
	OPERATOR_T,
	PARAM_T,
	TOKEN_SENTINAL,

	// Error tokens.  Returned so that we can
	// keep going on error (many use-cases benefit
	// from a best-efforts attempt to parse the rest
	// of the file).
	//
	UNTERMINATED_C_COMMENT_E,
	UNTERMINATED_BIT_STRING_E,
	UNTERMINATED_HEX_STRING_E,
	UNTERMINATED_QUOTED_STRING_E,
	UNTERMINATED_QUOTED_IDENTIFIER_E,
	UNTERMINATED_DOLQUOTE_STRING_E,
	STANDARD_CONFORMING_STRINGS_DISABLED_E,
	INVALID_UNICODE_ESCAPE_CHAR_E,
	INVALID_UNICODE_SURROGATE_PAIR_E,
	MALFORMED_DOLLAR_QUOTE_E,
	ZERO_LENGTH_QUOTED_IDENTIFIER_E,
	ZERO_LENGTH_UNICODE_IDENTIFIER_E,
	ERROR_SENTINAL,
	
	// All done.
	FINAL_SENTINAL
};
#undef PG_KEYWORD

enum TokenCategory {
	INVALID_TOKEN,
	LITERAL_TOKEN,
	IDENTIFIER_TOKEN,
	UNRESERVED_KEYWORD,
	RESERVED_KEYWORD,
	TYPE_FUNC_NAME_KEYWORD,
	COL_NAME_KEYWORD,
	WHITESPACE_TOKEN,
	COMMENT_TOKEN,
	OPERATOR_TOKEN,
	PARAMETER_TOKEN,
	ERROR_TOKEN
};

TokenId		keywordToId	(
			const char *text, 
			TokenId from = TokenId(INVALID + 1),
			TokenId to = KW_SENTINAL
		);
TokenCategory 	category	(TokenId id);
int 		lemonId		(TokenId id);
const char * 	idString	(TokenId id);
const char *	categoryString	(TokenCategory cat);


} // PGParse

#endif // TOKEN_ID_H