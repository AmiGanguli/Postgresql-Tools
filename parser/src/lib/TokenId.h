#if !defined (TOKEN_ID_H)
#define TOKEN_ID_H

#include <string>

namespace PGParse {

/**
 * We want to combine:
 * 
 *   1. the keyword information from the Postgres kwlist file.
 *   2. the token ids generated by Lemon.
 *   3. some additional metadata that we want to associate
 *      with tokens.
 * 
 * We keep a single list of token types, and then create a lookup
 * table to get at the additional information.  
 */

// Extract token identifiers from kwlist.h
//
#define PG_KEYWORD(text, id, category)		id##_KW,

enum TokenId {
	
	// INVALID is a catch-all error condition, and also
	// used as the starting sentinal for the list.
	//
	INVALID,
	
	// Keywords all end in _KW.  Taken directly from Postgres.
	//
#include "kwlist.h"
	KW_SENTINAL,
	
	// Other token types.
	//
	BIT_STRING_T,
	HEX_STRING_T,
	UNI_STRING_T,
	STRING_T,
	INTEGER_T,
	FLOAT_T,
	DOLQ_STRING_T,
	NCHAR_FLAG_T,
	IDENTIFIER_T,
	DQ_IDENTIFIER_T,
	UNICODE_IDENTIFIER_T,
	WHITESPACE_T,
	COMMENT_T,
	TYPECAST_T,
	DOTDOT_T,
	COLONEQUALS_T,
	COMMA_T,
	OPEN_PAREN_T,
	CLOSE_PAREN_T,
	OPEN_BRACKET_T,
	CLOSE_BRACKET_T,
	DOT_T,
	SEMI_COLON_T,
	COLON_T,
	PLUS_T,
	MINUS_T,
	STAR_T,
	SLASH_T,
	PERCENT_T,
	CARET_T,
	LESS_THAN_T,
	GREATER_THAN_T,
	EQUAL_T,
	OPERATOR_T,
	PARAM_T,
	TOKEN_SENTINAL,

	// Error tokens.  Returned so that we can
	// keep going on error (many use-cases benefit
	// from a best-efforts attempt to parse the rest
	// of the file).
	//
	UNTERMINATED_C_COMMENT_E,
	UNTERMINATED_BIT_STRING_E,
	UNTERMINATED_HEX_STRING_E,
	UNTERMINATED_QUOTED_STRING_E,
	UNTERMINATED_QUOTED_IDENTIFIER_E,
	UNTERMINATED_DOLQUOTE_STRING_E,
	STANDARD_CONFORMING_STRINGS_DISABLED_E,
	INVALID_UNICODE_ESCAPE_CHAR_E,
	INVALID_UNICODE_SURROGATE_PAIR_E,
	MALFORMED_DOLLAR_QUOTE_E,
	ZERO_LENGTH_QUOTED_IDENTIFIER_E,
	ZERO_LENGTH_UNICODE_IDENTIFIER_E,
	ERROR_SENTINAL,
	
	// All done.
	FINAL_SENTINAL
};
#undef PG_KEYWORD

// Designed to combine into flags.
//
// ERROR_TOKEN never appears on its own.  If we think we know what 
// the token was supposed to be, it's combined with that category.
// If we can't recognize it at all, then it's combined with INVALID_TOKEN.
//
enum TokenCategory {
	INVALID_TOKEN = 1,
	LITERAL_TOKEN = 2,
	IDENTIFIER_TOKEN = 4,
	
	KEYWORD_TOKEN = 8,
	
	KW_IS_UNRESERVED = 16,
	KW_IS_RESERVED = 32,
	KW_IS_TYPE_FUNC_NAME = 64,
	KW_IS_COL_NAME = 128,
	
	UNRESERVED_KEYWORD = 24,
	RESERVED_KEYWORD = 40,
	TYPE_FUNC_NAME_KEYWORD = 72,
	COL_NAME_KEYWORD = 136,
	
	TOKEN_IS_IGNORED = 256,
	TOKEN_IS_WHITESPACE = 512,
	TOKEN_IS_COMMENT = 1024,
	WHITESPACE_TOKEN = 768,
	COMMENT_TOKEN = 1280,
	
	OPERATOR_TOKEN = 2048,
	PARAMETER_TOKEN = 4096,
	ERROR_TOKEN = 8192,
	
	CATEGORIES_SENTINAL = 16384
};
typedef int CategoryFlags;

TokenId		keywordToId	(
			const char *text, 
			TokenId from = TokenId(INVALID + 1),
			TokenId to = KW_SENTINAL
		);
const char * 	idString	(TokenId id);
std::string	categoryString	(CategoryFlags category_flags);
int 		lemonId		(TokenId id);
int 		category	(TokenId id);

} // PGParse

#endif // TOKEN_ID_H